import { Status } from '@cucumber/cucumber';
import CucumberEventListener from './cucumberEventListener.js';
import { getFeatureId, formatMessage, getStepType, buildStepPayload } from './utils.js';
export default class CucumberReporter {
    _options;
    _cid;
    _specs;
    _reporter;
    eventListener;
    failedCount = 0;
    _tagsInTitle;
    _scenarioLevelReport;
    _featureStart;
    _scenarioStart;
    _testStart;
    constructor(eventBroadcaster, pickleFilter, _options, _cid, _specs, _reporter) {
        this._options = _options;
        this._cid = _cid;
        this._specs = _specs;
        this._reporter = _reporter;
        this._tagsInTitle = this._options.tagsInTitle || false;
        this._scenarioLevelReport = this._options.scenarioLevelReporter;
        this.eventListener = new CucumberEventListener(eventBroadcaster, pickleFilter)
            .on('before-feature', this.handleBeforeFeature.bind(this))
            .on('before-scenario', this.handleBeforeScenario.bind(this))
            .on('after-scenario', this.handleAfterScenario.bind(this))
            .on('after-feature', this.handleAfterFeature.bind(this));
        if (!this._scenarioLevelReport) {
            this.eventListener
                .on('before-step', this.handleBeforeStep.bind(this))
                .on('after-step', this.handleAfterStep.bind(this));
        }
    }
    handleBeforeFeature(uri, feature) {
        this._featureStart = new Date();
        this.emit('suite:start', {
            uid: getFeatureId(uri, feature),
            title: this.getTitle(feature),
            type: 'feature',
            file: uri,
            tags: feature.tags,
            description: feature.description,
            keyword: feature.keyword
        });
    }
    handleBeforeScenario(uri, feature, scenario) {
        this._scenarioStart = new Date();
        this._testStart = new Date();
        this.emit(this._scenarioLevelReport ? 'test:start' : 'suite:start', {
            uid: scenario.id,
            title: this.getTitle(scenario),
            parent: getFeatureId(uri, feature),
            type: 'scenario',
            file: uri,
            tags: scenario.tags,
            rule: scenario.rule
        });
    }
    handleBeforeStep(uri, feature, scenario, step) {
        this._testStart = new Date();
        const type = getStepType(step);
        const payload = buildStepPayload(uri, feature, scenario, step, { type });
        this.emit(`${type}:start`, payload);
    }
    handleAfterStep(uri, feature, scenario, step, result) {
        const type = getStepType(step);
        if (type === 'hook') {
            return this.afterHook(uri, feature, scenario, step, result);
        }
        return this.afterTest(uri, feature, scenario, step, result);
    }
    afterHook(uri, feature, scenario, step, result) {
        let error;
        if (result.message) {
            error = new Error(result.message.split('\n')[0]);
            error.stack = result.message;
        }
        const payload = buildStepPayload(uri, feature, scenario, step, {
            type: 'hook',
            state: result.status,
            error,
            duration: Date.now() - this._testStart?.getTime()
        });
        this.emit('hook:end', payload);
    }
    afterTest(uri, feature, scenario, step, result) {
        let state = 'undefined';
        switch (result.status) {
            case Status.FAILED:
            case Status.UNDEFINED:
                state = 'fail';
                break;
            case Status.PASSED:
                state = 'pass';
                break;
            case Status.PENDING:
                state = 'pending';
                break;
            case Status.SKIPPED:
                state = 'skip';
                break;
            case Status.AMBIGUOUS:
                state = 'pending';
                break;
        }
        let error = result.message ? new Error(result.message) : undefined;
        let title = step
            ? step?.text
            : this.getTitle(scenario);
        if (result.status === Status.UNDEFINED) {
            if (this._options.ignoreUndefinedDefinitions) {
                /**
                 * mark test as pending
                 */
                state = 'pending';
                title += ' (undefined step)';
            }
            else {
                /**
                 * mark test as failed
                 */
                this.failedCount++;
                const err = new Error((step ? `Step "${title}" is not defined. ` : `Scenario ${title} has undefined steps. `) +
                    'You can ignore this error by setting cucumberOpts.ignoreUndefinedDefinitions as true.');
                err.stack = `${err.message}\n\tat Feature(${uri}):1:1\n`;
                const featChildren = feature.children?.find(c => scenario.astNodeIds && c.scenario?.id === scenario.astNodeIds[0]);
                if (featChildren) {
                    err.stack += `\tat Scenario(${featChildren.scenario?.name}):${featChildren.scenario?.location?.line}:${featChildren.scenario?.location?.column}\n`;
                    const featStep = featChildren.scenario?.steps?.find(s => step.astNodeIds && s.id === step.astNodeIds[0]);
                    if (featStep) {
                        err.stack += `\tat Step(${featStep.text}):${featStep.location?.line}:${featStep.location?.column}\n`;
                    }
                }
                error = err;
            }
        }
        else if (result.status === Status.FAILED && !result.willBeRetried) {
            error = new Error(result.message?.split('\n')[0]);
            error.stack = result.message;
            this.failedCount++;
        }
        else if (result.status === Status.AMBIGUOUS && this._options.failAmbiguousDefinitions) {
            state = 'fail';
            this.failedCount++;
            error = new Error(result.message?.split('\n')[0]);
            error.stack = result.message;
        }
        else if (result.willBeRetried) {
            state = 'retry';
        }
        const common = {
            title: title,
            state,
            error,
            duration: Date.now() - this._testStart?.getTime(),
            passed: ['pass', 'skip'].includes(state),
            file: uri
        };
        const payload = step
            ? buildStepPayload(uri, feature, scenario, step, {
                type: 'step',
                ...common
            })
            : {
                type: 'scenario',
                uid: scenario.id,
                parent: getFeatureId(uri, feature),
                tags: scenario.tags,
                ...common
            };
        this.emit('test:' + state, payload);
    }
    handleAfterScenario(uri, feature, scenario, result) {
        if (this._scenarioLevelReport) {
            return this.afterTest(uri, feature, scenario, { id: scenario.id }, result);
        }
        this.emit('suite:end', {
            uid: scenario.id,
            title: this.getTitle(scenario),
            parent: getFeatureId(uri, feature),
            type: 'scenario',
            file: uri,
            duration: Date.now() - this._scenarioStart?.getTime(),
            tags: scenario.tags
        });
    }
    handleAfterFeature(uri, feature) {
        this.emit('suite:end', {
            uid: getFeatureId(uri, feature),
            title: this.getTitle(feature),
            type: 'feature',
            file: uri,
            duration: Date.now() - this._featureStart?.getTime(),
            tags: feature.tags
        });
    }
    emit(event, payload) {
        const message = formatMessage({ payload });
        message.cid = this._cid;
        message.specs = this._specs;
        message.uid = payload.uid;
        this._reporter.emit(event, message);
    }
    getTitle(featureOrScenario) {
        const name = featureOrScenario.name;
        const tags = featureOrScenario.tags;
        if (!this._tagsInTitle || !tags || !tags.length) {
            return name;
        }
        return `${tags.map((tag) => tag.name).join(', ')}: ${name}`;
    }
}
